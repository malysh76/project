/*
 * flash.c
 * Работа с флеш памятью контроллера
 * функции разместить в области RAM
 * для KEIL
 * в sct файле сделать следующую правку
 * 		RW_IRAM1 0x20000000 UNINIT 0x00008000  {  ; RW data
    		eeprom.o (+RO)
   	   	   .ANY (+RW +ZI)
  }
 *
 *  Created on: 04.05.2011
 *      Author: 129
 */
#include "common1.h"
#include "1986ve9x_irq.h"
#include "1986ve9x_clk.h"
#include "eeprom.h"
#include "adr.h"
// для отладки
//#include "defports.h"

//unsigned char BufData[0x1000];
//void 	EEPROM_irq		(TIRQ_State irq_state);
void 	EEPROM_irq		(FunctionalState irq_state);


/*------------------------------------------------------------------------------
 *  ИНИЦИАЛИЗАЦИЯ EEPROM
 *----------------------------------------------------------------------------*/
void EEPROM_Init(void)
{
	PER_CLOCK |= (unsigned long)1<<nEEPROM_CNTRL;
}


/*-----------------------------------------------------------------------------
 * СТИРАНИЕ ВСЕЙ ПАМЯТИ
 * Стирание памяти возможно только в режиме программирования. Для стирание всей
 * памяти надо установить  необходимое значение в бит IFREN
 * (1 – для информационной памяти и 0 – для основной памяти), затем установить
 * биты XE, MAS1 и ERASE в единицу, и спустя время tnvs = 5 мкс установить бит
 * NVSTR в единицу. Полное стирание памяти длиться время tme = 40 мс.
 * Спустя это время необходимо очистить бит ERASE, и спустя время
 * tnvh1 = 100 мкс очистить биты XE, MAS1 и NVSTR. Последующие операции с память
 * можно выполнять спустя время trcv = 1
 * Если TypeMem = MEM_BAS, то стирается только основная память.
 * Если TypeMem = MEM_INF, то стирается и основная и информационная память.
 *----------------------------------------------------------------------------*/
void EEPROM_Erase (TTypeMem TypeMem)
{
// перевод в режим программирования
	EEPROM_PRG();
// выбор типа памяти
	EEPROM_CMD |= TypeMem;
	EEPROM_CMD |= XE|MAS1|ERASE;
	EEPROM_Sleep(6);		// 5.5us
	EEPROM_CMD |= NVSTR;	// NVSTR=1
	EEPROM_Sleep(16000);	// 16ms
	EEPROM_Sleep(16000);	// 16ms
	EEPROM_Sleep(16000);	// 16ms
	EEPROM_CMD &= ~ERASE;	// ERASE=0
	EEPROM_Sleep(120);		// 5.5us
	EEPROM_CMD &= ~XE;		// XE=0
	EEPROM_CMD &= ~MAS1;	// NVSTR=0
	EEPROM_CMD &= ~NVSTR;	// NVSTR=0
	EEPROM_Sleep(1); 		// 1.8us
// перевод  в рабочий режим
	EEPROM_WRK();
}


/*-----------------------------------------------------------------------------
 * СТИРАНИЕ СТРАНИЦЫ
 * Стирание страницы  памяти возможно только в режиме программирования.
 * Для стирание страницы памяти надо установить  необходимое значение
 * в бит IFREN (1 – для информационной памяти и 0 – для основной памяти),
 * затем установить адрес стираемой страницы в регистре EEPROM_ADR
 * и установить биты XE и ERASE в единицу, и спустя время tnvs = 5 мкс
 * установить бит  NVSTR в единицу. Стирание страницы памяти длиться время
 * terase = 40 мс. Спустя это время необходимо очистить бит ERASE, и спустя
 * время tnvh = 5 мкс очистить биты XE и NVSTR. Последующие операции с память
 * можно выполнять спустя время trcv = 1 мкс.
 *----------------------------------------------------------------------------*/
void  EEPROM_ErasePage (TTypeMem TypeMem, unsigned long Addr)
{
	unsigned char i;
	// перевод в режим программирования
	EEPROM_PRG();
// выбор типа памяти
	EEPROM_CMD |= TypeMem;
	for(i = 0; i<4;i++)
	{
		EEPROM_ADR = Addr+i*4;
		EEPROM_CMD |= XE;		// XE=1
		EEPROM_CMD |= ERASE;	// ERASE=1
		EEPROM_Sleep(6);		// 5.5us
		EEPROM_CMD |= NVSTR;	// NVSTR=1
		EEPROM_Sleep(16000);	// 16ms
		EEPROM_Sleep(16000);	// 16ms
		EEPROM_Sleep(8000);	// 8ms
		EEPROM_CMD &= ~ERASE;	// ERASE=0
		EEPROM_Sleep(6);		// 5.5us
		EEPROM_CMD &= ~XE;		// XE=0
		EEPROM_CMD &= ~NVSTR;	// NVSTR=0
		EEPROM_Sleep(2); 		// 1.8us
	}
// перевод  в рабочий режим
	EEPROM_WRK();
}

/*-----------------------------------------------------------------------------
 * ЗАПИСЬ ДАННЫХ В EEPROM
 * Запись в память возможно только в режиме программирования. Для записи
 * в память надо установить  необходимое значение в бит IFREN
 * (1 – для информационной памяти и 0 – для основной памяти), затем установить
 * адрес по которому производится запись в регистре EEPROM_ADR,
 * в регистр EEPROM_DI записать записываемое в память слово и установить биты
 * XE и PROG в единицу, и спустя время tnvs = 5 мкс установить бит  NVSTR
 * в единицу. Спустя время tpgs = 10 мкс установить бит YE в единицу. Запись в
 * память длиться время tprog = 40 мкс. Спустя это время необходимо очистить
 * бит YE, и спустя время tadh = 20 нс установить новый адрес и значение для
 * записи в другую ячейку памяти. И спустя tadh = 20 нс установить YE в единицу
 * и записать следующую слово. Если запись больше не требуется, то спустя
 * время tpgh = 20 нс после очистки бита YE необходимо очистить бит PROG и
 * спустя время tnvh = 5 мкс очистить биты XE и NVSTR..   Последующие операции
 * с память можно выполнять спустя время trcv = 1 мкс.
 * TypeMem 	- тип памяти
 * Addr 	- адрес записи
 * Data 	- указатель на массив данных
 * len 		- длина блока данных в байтах
 *----------------------------------------------------------------------------*/
void EEPROM_WriteData(TTypeMem TypeMem,unsigned long Addr, unsigned char* Data, unsigned short len)
{
	//переход в режим программирования
	EEPROM_PRG();

	// установка типа памяти
	EEPROM_CMD |= TypeMem;
	// округление в большую сторону до ближайшего кратного 4
	len += 3;
	len &= ~(unsigned long)3;
	while(len)
	{
		// установка адреса
		EEPROM_ADR = Addr;
		// запись данных
		EEPROM_DI = *(unsigned long*)Data;
		EEPROM_CMD |= XE|PROG;
		EEPROM_Sleep(5);
		EEPROM_CMD |= NVSTR;
		EEPROM_Sleep(10);// было 10 поставил 12 из за ошибки crc
		EEPROM_CMD |= YE;
		EEPROM_Sleep(40);// было 40
		EEPROM_CMD &= ~YE;
		__nop();
		__nop();
		__nop();		// добавил
		EEPROM_CMD &= ~PROG;
		EEPROM_Sleep(5);
		EEPROM_CMD &= ~NVSTR;
		EEPROM_CMD &= ~XE;
		EEPROM_Sleep(1);
		Addr += 4;
		Data += 4;
		len -= 4;
	}
	// переход в рабочий режим
	EEPROM_WRK();
}

/*-----------------------------------------------------------------------------
 * ЧТЕНИЕ ДАННЫХ ИЗ EEPROM
 * В обычном режиме работы для чтения доступна только основная память. Для этого
 * необходимо просто считать требуемый адрес памяти. В режиме программирования
 * для чтения доступна и основная и информационная память. Для чтения из памяти
 * надо установить  необходимое значение в бит IFREN (1 – для информационной
 * памяти и 0 – для основной памяти), затем установить адрес из которого
 * необходимо считать данные в регистре EEPROM_ADR и установить биты XE, YE и
 * SE в единицу, и спустя время txa = 30 нс из регистра EEPROM_DO можно считать
 * данные. Если необходимо считать следующее слово, то в регистр EEPROM_ADR
 * необходимо записать новый адрес и спустя время txa = 30 нс из регистра
 * EEPROM_DO можно считать следующие данные Если чтение больше не требуется,
 * то можно очистить все биты управления. Временная диаграмма чтения памяти
 * представлена на Рисунок 18 – Временная диаграмма чтения памяти.
 *----------------------------------------------------------------------------*/
void EEPROM_ReadData(TTypeMem TypeMem,unsigned long Addr, unsigned char* Data,unsigned short len)
{
	unsigned char dat[4];	// переменная для считанного результата
	unsigned char i;		// текущая длина считанных данных
	unsigned char j;		// позиция при копировании байта

	if(!TypeMem)
	{
		while(len)
		{
			*Data = *(unsigned char*)Addr;
			Data++;
			Addr++;
			len--;
		}
		return;
	}

	// переход в режим программирования
	EEPROM_PRG();
	// установка типа памяти
	EEPROM_CMD |= TypeMem;
	while(len)
	{
		EEPROM_ADR = Addr;
		EEPROM_CMD |= XE|YE|SE;
		EEPROM_DO;
		EEPROM_DO;
		EEPROM_DO;
		*(unsigned long*)dat = EEPROM_DO;
		EEPROM_CMD &= ~XE;
		EEPROM_CMD &= ~YE;
		EEPROM_CMD &= ~SE;
		// вычисление текущей считанной длинны
		j = i = (len<4?len:4);
		// копирование в заданный массив
		while(i)
		{
			*Data = dat[j-i];
			Data++;
			i--;
			len--;
		}
		Addr+=4;
	}
	EEPROM_WRK();
}

/*------------------------------------------------------------------------------
 * РАЗРЕШЕНИЕ ИЛИ ЗАПРЕТ ПРЕРЫВАНИЙ
 *-----------------------------------------------------------------------------*/
//void EEPROM_irq(TIRQ_State irq_state)
void EEPROM_irq(FunctionalState irq_state)
{
	static unsigned long IER[8];
	unsigned char i;
	if(irq_state == ENABLE)
	{
		// восстановление разрешенных прерываний
		for(i = 0; i<8; i++)
			NVIC->ISER[i] = IER[i];

	}
	else
	{
		for(i = 0; i<8; i++)
		{
			// сохраняем разрешенные прерывания
			IER[i] = NVIC->ISER[i];
			// запрет всех прерываний
			NVIC->ICER[i] = 0xFFFFFFFF;
		}

	}

}

/*------------------------------------------------------------------------------
 * Копирование кода загрузчика
 * 0 - ADDR_BACKUP_BOOT - > ADDR_BOOT без изменения crc
 * 1 - ADDR_BOOT - > ADDR_BACKUP_BOOT без изменения crc
 * 2 - ADDR_BACKUP_BOOT - > ADDR_BOOT c изменения crc
 * 3 - ADDR_BOOT - > ADDR_BACKUP_BOOT c изменения crc
 *------------------------------------------------------------------------------*/
/*
void EEPROM_boot(void)
{
	unsigned long cnt;
// проверка контрольной суммы загрузчика


// создание backup загрузчика
	for(cnt = 0;cnt<SIZE_OF_PAGE;cnt++)
		BufData[cnt] = *(unsigned char*)(ADDR_BOOT+cnt);
	EEPROM_ErasePage(MEM_BAS,ADDR_BACKUP_BOOT);
	EEPROM_WriteData(MEM_BAS,ADDR_BACKUP_BOOT,BufData,SIZE_OF_PAGE);
}
*/
